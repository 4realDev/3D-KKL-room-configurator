/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useState, useEffect, useRef } from 'react';
import { useGLTF } from '@react-three/drei';
// update: useProxy seems not to work anymore
import { useSnapshot } from 'valtio';
import { state } from '../../common/state';

useGLTF.preload('/kkl-prototype-adjusted.glb');

const Model = ({ meshList, setMeshList }) => {
	const group = useRef();
	const { nodes, materials } = useGLTF('/kkl-prototype-adjusted.glb');

	// Set up state for the hovered and active state
	const [hoveredElement, setHoveredElement] = useState(null);

	const opacityValue = 0.1;
	const hoverColor = 'hotpink';

	// use state inside the component
	const snap = useSnapshot(state);
	const initialMeshList = [];

	const convertGLTFToMeshList = (nodes, materials) => {
		let nodeName = [];
		let nodeGeometry = [];
		let nodeMaterial = [];

		const meshes = nodes;
		delete meshes.Scene;
		delete meshes.Camera;
		delete meshes.Light;

		Object.values(meshes).forEach((mesh) => {
			nodeName.push(mesh.name);
			nodeGeometry.push(mesh.geometry);
		});

		Object.values(materials).forEach((material) => {
			nodeMaterial.push(material);
		});

		for (var i = 0; i < nodeName.length; i++) {
			initialMeshList.push({
				name: nodeName[i],
				geometry: nodeGeometry[i],
				material: nodeMaterial[i],
				color: '#ffffff',
				opacity: 1,
			});
		}
	};

	useEffect(() => {
		convertGLTFToMeshList(nodes, materials);
		setMeshList(initialMeshList);
	}, []);

	return (
		<group
			scale='0.5'
			ref={group}
			dispose={null}
			// events for all meshes

			// Pointer on mesh
			// if pointer is over a mesh, stop propagation of the event
			// and set the material name as the hoveredElement
			onPointerOver={(event) => {
				event.stopPropagation();
				setHoveredElement(event.object.material.name);
			}}
			// Pointer outside of mesh
			// if pointer is outside of a mesh and does not intersect with any other mesh
			// set the hoveredElement to null
			onPointerOut={(event) => {
				event.intersections.length === 0 && setHoveredElement(null);
			}}
			// Pointer click on mesh
			// stopPropagation and set current object inside state to the one clicked
			onPointerDown={(event) => {
				event.stopPropagation();
				state.current = event.object.material.name;
				// event.object.material.visible = false;
			}}
			// Pointer click outside of mesh
			// Set current object inside state to the one clicked
			onPointerMissed={(event) => {
				state.current = null;
			}}
		>
			{meshList.map((meshObject) => {
				return (
					<mesh
						geometry={meshObject.geometry}
						material={meshObject.material}
						material-color={
							hoveredElement === meshObject.name ? hoverColor : meshObject.color
						}
						material-transparent={true}
						material-opacity={
							snap.selected !== null && snap.selected !== meshObject.name
								? opacityValue
								: meshObject.opacity
						}
					/>
				);
			})}
			{/* <mesh
				geometry={nodes.roof.geometry}
				material={materials.roof}
				material-color={
					hoveredElement === materials.roof.name
						? hoverColor
						: snap.items.roof.color
				}
				material-transparent={true}
				material-opacity={
					snap.selected !== null && snap.selected !== materials.roof.name
						? opacityValue
						: snap.items.roof.opacity
				}
			/> */}
			{/* <mesh
				geometry={nodes.windows.geometry}
				material={materials.windows}
				material-color={
					hoveredElement === materials.windows.name
						? hoverColor
						: snap.items.windows.color
				}
				material-transparent={true}
				material-opacity={
					snap.selected !== null && snap.selected !== materials.windows.name
						? opacityValue
						: snap.items.windows.opacity
				}
			/>
			<mesh
				geometry={nodes.outer_walls.geometry}
				material={materials.outer_walls}
				material-color={
					hoveredElement === materials.outer_walls.name
						? hoverColor
						: snap.items.outer_walls.color
				}
				material-transparent={true}
				material-opacity={
					snap.selected !== null && snap.selected !== materials.outer_walls.name
						? opacityValue
						: snap.items.outer_walls.opacity
				}
			/>
			<mesh
				geometry={nodes.stairs.geometry}
				material={materials.stairs}
				material-color={
					hoveredElement === materials.stairs.name
						? hoverColor
						: snap.items.stairs.color
				}
				material-transparent={true}
				material-opacity={
					snap.selected !== null && snap.selected !== materials.stairs.name
						? opacityValue
						: snap.items.stairs.opacity
				}
			/>
			<mesh
				geometry={nodes.fence.geometry}
				material={materials.fence}
				material-color={
					hoveredElement === materials.fence.name
						? hoverColor
						: snap.items.fence.color
				}
				material-transparent={true}
				material-opacity={
					snap.selected !== null && snap.selected !== materials.fence.name
						? opacityValue
						: snap.items.fence.opacity
				}
			/>
			<mesh
				geometry={nodes.balcony.geometry}
				material={materials.balcony}
				material-color={
					hoveredElement === materials.balcony.name
						? hoverColor
						: snap.items.balcony.color
				}
				material-transparent={true}
				material-opacity={
					snap.selected !== null && snap.selected !== materials.balcony.name
						? opacityValue
						: snap.items.balcony.opacity
				}
			/>
			<mesh
				geometry={nodes.doors.geometry}
				material={materials.doors}
				material-color={
					hoveredElement === materials.doors.name
						? hoverColor
						: snap.items.doors.color
				}
				material-transparent={true}
				material-opacity={
					snap.selected !== null && snap.selected !== materials.doors.name
						? opacityValue
						: snap.items.doors.opacity
				}
			/>
			<mesh
				geometry={nodes.floor.geometry}
				material={materials.floor}
				material-color={
					hoveredElement === materials.floor.name
						? hoverColor
						: snap.items.floor.color
				}
				material-transparent={true}
				material-opacity={
					snap.selected !== null && snap.selected !== materials.floor.name
						? opacityValue
						: snap.items.floor.opacity
				}
			/>
			<mesh
				geometry={nodes.inner_walls.geometry}
				material={materials.inner_walls}
				material-color={
					hoveredElement === materials.inner_walls.name
						? hoverColor
						: snap.items.inner_walls.color
				}
				material-transparent={true}
				material-opacity={
					snap.selected !== null && snap.selected !== materials.inner_walls.name
						? opacityValue
						: snap.items.inner_walls.opacity
				}
			/> */}
		</group>
	);
};

export default Model;

useGLTF.preload('/prototypeHouse.glb');
